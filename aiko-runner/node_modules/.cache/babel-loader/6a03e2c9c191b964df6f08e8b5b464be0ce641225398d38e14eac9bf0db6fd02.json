{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kavya\\\\source\\\\repos\\\\AikoGame\\\\aiko-runner\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst OBSTACLE_CONFIG = {\n  1: {\n    width: 140,\n    height: 160\n  },\n  // Obstacle1.png\n  2: {\n    width: 100,\n    height: 120\n  } // Obstacle2.png\n};\nfunction App() {\n  _s();\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Game loop for moving and spawning obstacles\n  useEffect(() => {\n    if (gameOver) return;\n    const gameInterval = setInterval(() => {\n      // Move existing obstacles\n      setObstacles(prevObstacles => {\n        const updatedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 10 // Speed of obstacles\n        }));\n\n        // Check for scoring\n        updatedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoX) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // Filter out obstacles that are off-screen\n        return updatedObstacles.filter(obs => obs.x > -200);\n      });\n\n      // Spawn new obstacles\n      setObstacles(prevObstacles => {\n        const lastObstacle = prevObstacles[prevObstacles.length - 1];\n        // Spawn a new obstacle if there are none, or if the last one is far enough away\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          return [...prevObstacles, {\n            id: Date.now(),\n            x: window.innerWidth,\n            type: newObstacleType,\n            width: OBSTACLE_CONFIG[newObstacleType].width,\n            height: OBSTACLE_CONFIG[newObstacleType].height,\n            scored: false\n          }];\n        }\n        return prevObstacles;\n      });\n    }, 30);\n    return () => clearInterval(gameInterval);\n  }, [gameOver, aikoX]);\n\n  // Collision detection\n  useEffect(() => {\n    const aikoHitbox = {\n      width: 50,\n      height: 100,\n      paddingX: 45\n    };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY]);\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Score: \", score]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 7\n    }, this), gameOver ? /*#__PURE__*/_jsxDEV(GameOver, {\n      onRestart: handleRestart\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(AikoRunner, {\n        setY: setAikoY,\n        setX: setAikoX,\n        gameOver: gameOver\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 102,\n        columnNumber: 11\n      }, this), obstacles.map(obs => /*#__PURE__*/_jsxDEV(Obstacle, {\n        x: obs.x,\n        type: obs.type\n      }, obs.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 104,\n        columnNumber: 13\n      }, this))]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 96,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"oja+srUFcUgJ8n4HI1c+UCJ0Z1w=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","AikoRunner","Obstacle","GameOver","jsxDEV","_jsxDEV","Fragment","_Fragment","OBSTACLE_CONFIG","width","height","App","_s","obstacles","setObstacles","score","setScore","aikoY","setAikoY","aikoX","setAikoX","gameOver","setGameOver","gameInterval","setInterval","prevObstacles","updatedObstacles","map","obs","x","forEach","scored","s","filter","lastObstacle","length","window","innerWidth","newObstacleType","Math","random","id","Date","now","type","clearInterval","aikoHitbox","paddingX","aikoLeft","aikoRight","aikoBottom","isHorizontallyOverlapping","isVerticallyOverlapping","handleRestart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onRestart","setY","setX","_c","$RefreshReg$"],"sources":["C:/Users/kavya/source/repos/AikoGame/aiko-runner/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nconst OBSTACLE_CONFIG = {\n  1: { width: 140, height: 160 }, // Obstacle1.png\n  2: { width: 100, height: 120 }  // Obstacle2.png\n};\n\nfunction App() {\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Game loop for moving and spawning obstacles\n  useEffect(() => {\n    if (gameOver) return;\n\n    const gameInterval = setInterval(() => {\n      // Move existing obstacles\n      setObstacles(prevObstacles => {\n        const updatedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 10 // Speed of obstacles\n        }));\n\n        // Check for scoring\n        updatedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoX) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // Filter out obstacles that are off-screen\n        return updatedObstacles.filter(obs => obs.x > -200);\n      });\n\n      // Spawn new obstacles\n      setObstacles(prevObstacles => {\n        const lastObstacle = prevObstacles[prevObstacles.length - 1];\n        // Spawn a new obstacle if there are none, or if the last one is far enough away\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          return [\n            ...prevObstacles,\n            {\n              id: Date.now(),\n              x: window.innerWidth,\n              type: newObstacleType,\n              width: OBSTACLE_CONFIG[newObstacleType].width,\n              height: OBSTACLE_CONFIG[newObstacleType].height,\n              scored: false\n            }\n          ];\n        }\n        return prevObstacles;\n      });\n    }, 30);\n\n    return () => clearInterval(gameInterval);\n  }, [gameOver, aikoX]);\n\n  // Collision detection\n  useEffect(() => {\n    const aikoHitbox = { width: 50, height: 100, paddingX: 45 };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY]);\n\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n\n  return (\n    <div className=\"game-container\">\n      <h1>Score: {score}</h1>\n      {gameOver ? (\n        <GameOver onRestart={handleRestart} />\n      ) : (\n        <>\n          <AikoRunner setY={setAikoY} setX={setAikoX} gameOver={gameOver} />\n          {obstacles.map(obs => (\n            <Obstacle key={obs.id} x={obs.x} type={obs.type} />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}