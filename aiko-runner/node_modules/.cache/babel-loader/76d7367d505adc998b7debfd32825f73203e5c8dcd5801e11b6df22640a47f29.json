{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kavya\\\\source\\\\repos\\\\AikoGame\\\\aiko-runner\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react'; // Import useRef\nimport axios from 'axios'; // Import axios\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst OBSTACLE_CONFIG = {\n  1: {\n    width: 140,\n    height: 160\n  },\n  // Obstacle1.png\n  2: {\n    width: 100,\n    height: 120\n  } // Obstacle2.png\n};\nfunction App() {\n  _s();\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(0); // State for high score\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Use a ref to track aiko's position inside the game loop without causing re-renders\n  const aikoXRef = useRef(aikoX);\n  useEffect(() => {\n    aikoXRef.current = aikoX;\n  }, [aikoX]);\n\n  // Fetch high score on initial load\n  useEffect(() => {\n    axios.get('https://localhost:7163/api/score').then(res => setHighScore(res.data)).catch(err => console.error(\"Could not fetch high score:\", err));\n  }, []);\n\n  // --- FIX: Refactored Game Loop ---\n  useEffect(() => {\n    if (gameOver) return;\n    const gameInterval = setInterval(() => {\n      // Perform all obstacle logic in one state update\n      setObstacles(prevObstacles => {\n        // 1. Move obstacles\n        const movedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 5 // Speed of obstacles\n        }));\n\n        // 2. Check for scoring using the up-to-date ref\n        movedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoXRef.current) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // 3. Filter out off-screen obstacles\n        let updatedObstacles = movedObstacles.filter(obs => obs.x > -200);\n\n        // 4. Spawn new obstacles\n        const lastObstacle = updatedObstacles[updatedObstacles.length - 1];\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          updatedObstacles.push({\n            id: Date.now(),\n            x: window.innerWidth,\n            type: newObstacleType,\n            width: OBSTACLE_CONFIG[newObstacleType].width,\n            height: OBSTACLE_CONFIG[newObstacleType].height,\n            scored: false\n          });\n        }\n        return updatedObstacles;\n      });\n    }, 30);\n    return () => clearInterval(gameInterval);\n  }, [gameOver]); // The loop only depends on the gameOver state\n\n  // Collision detection\n  useEffect(() => {\n    if (gameOver) return; // Don't check for collisions if game is already over\n\n    const aikoHitbox = {\n      width: 50,\n      height: 100,\n      paddingX: 45\n    };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        // Post final score to the backend\n        axios.post('https://localhost:7163/api/score', {\n          score\n        }).then(res => setHighScore(res.data)).catch(err => console.error(\"Could not post score:\", err));\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY, gameOver, score]); // Add gameOver and score to dependencies\n\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"score-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: [\"Score: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 115,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: [\"High Score: \", highScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }, this), gameOver ? /*#__PURE__*/_jsxDEV(GameOver, {\n      onRestart: handleRestart\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(AikoRunner, {\n        setY: setAikoY,\n        setX: setAikoX,\n        gameOver: gameOver\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 122,\n        columnNumber: 11\n      }, this), obstacles.map(obs => /*#__PURE__*/_jsxDEV(Obstacle, {\n        x: obs.x,\n        type: obs.type\n      }, obs.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 13\n      }, this))]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 112,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"oGAwphNEJj1zqlNiVHSkmkF4NZw=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","axios","AikoRunner","Obstacle","GameOver","jsxDEV","_jsxDEV","Fragment","_Fragment","OBSTACLE_CONFIG","width","height","App","_s","obstacles","setObstacles","score","setScore","highScore","setHighScore","aikoY","setAikoY","aikoX","setAikoX","gameOver","setGameOver","aikoXRef","current","get","then","res","data","catch","err","console","error","gameInterval","setInterval","prevObstacles","movedObstacles","map","obs","x","forEach","scored","s","updatedObstacles","filter","lastObstacle","length","window","innerWidth","newObstacleType","Math","random","push","id","Date","now","type","clearInterval","aikoHitbox","paddingX","aikoLeft","aikoRight","aikoBottom","isHorizontallyOverlapping","isVerticallyOverlapping","post","handleRestart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onRestart","setY","setX","_c","$RefreshReg$"],"sources":["C:/Users/kavya/source/repos/AikoGame/aiko-runner/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react'; // Import useRef\nimport axios from 'axios'; // Import axios\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nconst OBSTACLE_CONFIG = {\n  1: { width: 140, height: 160 }, // Obstacle1.png\n  2: { width: 100, height: 120 }  // Obstacle2.png\n};\n\nfunction App() {\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(0); // State for high score\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Use a ref to track aiko's position inside the game loop without causing re-renders\n  const aikoXRef = useRef(aikoX);\n  useEffect(() => {\n    aikoXRef.current = aikoX;\n  }, [aikoX]);\n\n  // Fetch high score on initial load\n  useEffect(() => {\n    axios.get('https://localhost:7163/api/score')\n      .then(res => setHighScore(res.data))\n      .catch(err => console.error(\"Could not fetch high score:\", err));\n  }, []);\n\n  // --- FIX: Refactored Game Loop ---\n  useEffect(() => {\n    if (gameOver) return;\n\n    const gameInterval = setInterval(() => {\n      // Perform all obstacle logic in one state update\n      setObstacles(prevObstacles => {\n        // 1. Move obstacles\n        const movedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 5 // Speed of obstacles\n        }));\n\n        // 2. Check for scoring using the up-to-date ref\n        movedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoXRef.current) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // 3. Filter out off-screen obstacles\n        let updatedObstacles = movedObstacles.filter(obs => obs.x > -200);\n\n        // 4. Spawn new obstacles\n        const lastObstacle = updatedObstacles[updatedObstacles.length - 1];\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          updatedObstacles.push({\n            id: Date.now(),\n            x: window.innerWidth,\n            type: newObstacleType,\n            width: OBSTACLE_CONFIG[newObstacleType].width,\n            height: OBSTACLE_CONFIG[newObstacleType].height,\n            scored: false\n          });\n        }\n        return updatedObstacles;\n      });\n    }, 30);\n\n    return () => clearInterval(gameInterval);\n  }, [gameOver]); // The loop only depends on the gameOver state\n\n  // Collision detection\n  useEffect(() => {\n    if (gameOver) return; // Don't check for collisions if game is already over\n\n    const aikoHitbox = { width: 50, height: 100, paddingX: 45 };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        // Post final score to the backend\n        axios.post('https://localhost:7163/api/score', { score })\n          .then(res => setHighScore(res.data))\n          .catch(err => console.error(\"Could not post score:\", err));\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY, gameOver, score]); // Add gameOver and score to dependencies\n\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n\n  return (\n    <div className=\"game-container\">\n      {/* Display Score and High Score */}\n      <div className=\"score-container\">\n        <h1>Score: {score}</h1>\n        <h2>High Score: {highScore}</h2>\n      </div>\n      {gameOver ? (\n        <GameOver onRestart={handleRestart} />\n      ) : (\n        <>\n          <AikoRunner setY={setAikoY} setX={setAikoX} gameOver={gameOver} />\n          {obstacles.map(obs => (\n            <Obstacle key={obs.id} x={obs.x} type={obs.type} />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}