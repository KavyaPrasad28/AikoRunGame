{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kavya\\\\source\\\\repos\\\\AikoGame\\\\aiko-runner\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios'; // Import axios\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst OBSTACLE_CONFIG = {\n  1: {\n    width: 140,\n    height: 160\n  },\n  // Obstacle1.png\n  2: {\n    width: 100,\n    height: 120\n  } // Obstacle2.png\n};\nfunction App() {\n  _s();\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(0); // State for high score\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Fetch high score on initial load\n  useEffect(() => {\n    axios.get('https://localhost:7163/api/score').then(res => setHighScore(res.data)).catch(err => console.error(\"Could not fetch high score:\", err));\n  }, []);\n\n  // Game loop for moving and spawning obstacles\n  useEffect(() => {\n    if (gameOver) return;\n    const gameInterval = setInterval(() => {\n      // Move existing obstacles\n      setObstacles(prevObstacles => {\n        const updatedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 5 // Speed of obstacles\n        }));\n\n        // Check for scoring\n        updatedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoX) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // Filter out obstacles that are off-screen\n        return updatedObstacles.filter(obs => obs.x > -200);\n      });\n\n      // Spawn new obstacles\n      setObstacles(prevObstacles => {\n        const lastObstacle = prevObstacles[prevObstacles.length - 1];\n        // Spawn a new obstacle if there are none, or if the last one is far enough away\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          return [...prevObstacles, {\n            id: Date.now(),\n            x: window.innerWidth,\n            type: newObstacleType,\n            width: OBSTACLE_CONFIG[newObstacleType].width,\n            height: OBSTACLE_CONFIG[newObstacleType].height,\n            scored: false\n          }];\n        }\n        return prevObstacles;\n      });\n    }, 30);\n    return () => clearInterval(gameInterval);\n  }, [gameOver, aikoX]);\n\n  // Collision detection\n  useEffect(() => {\n    if (gameOver) return; // Don't check for collisions if game is already over\n\n    const aikoHitbox = {\n      width: 50,\n      height: 100,\n      paddingX: 45\n    };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        // Post final score to the backend\n        axios.post('https://localhost:7163/api/score', {\n          score\n        }).then(res => setHighScore(res.data)).catch(err => console.error(\"Could not post score:\", err));\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY, gameOver, score]); // Add gameOver and score to dependencies\n\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"score-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: [\"Score: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: [\"High Score: \", highScore]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 115,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }, this), gameOver ? /*#__PURE__*/_jsxDEV(GameOver, {\n      onRestart: handleRestart\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(AikoRunner, {\n        setY: setAikoY,\n        setX: setAikoX,\n        gameOver: gameOver\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 121,\n        columnNumber: 11\n      }, this), obstacles.map(obs => /*#__PURE__*/_jsxDEV(Obstacle, {\n        x: obs.x,\n        type: obs.type\n      }, obs.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 13\n      }, this))]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 111,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"+kpPhsPetD0ynJ+4H38Lcwdftj8=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","axios","AikoRunner","Obstacle","GameOver","jsxDEV","_jsxDEV","Fragment","_Fragment","OBSTACLE_CONFIG","width","height","App","_s","obstacles","setObstacles","score","setScore","highScore","setHighScore","aikoY","setAikoY","aikoX","setAikoX","gameOver","setGameOver","get","then","res","data","catch","err","console","error","gameInterval","setInterval","prevObstacles","updatedObstacles","map","obs","x","forEach","scored","s","filter","lastObstacle","length","window","innerWidth","newObstacleType","Math","random","id","Date","now","type","clearInterval","aikoHitbox","paddingX","aikoLeft","aikoRight","aikoBottom","isHorizontallyOverlapping","isVerticallyOverlapping","post","handleRestart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onRestart","setY","setX","_c","$RefreshReg$"],"sources":["C:/Users/kavya/source/repos/AikoGame/aiko-runner/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport axios from 'axios'; // Import axios\nimport AikoRunner from './components/AikoRunner';\nimport Obstacle from './components/Obstacle';\nimport GameOver from './components/GameOver';\nimport './App.css';\n\n// Define obstacle properties, including their different widths\nconst OBSTACLE_CONFIG = {\n  1: { width: 140, height: 160 }, // Obstacle1.png\n  2: { width: 100, height: 120 }  // Obstacle2.png\n};\n\nfunction App() {\n  const [obstacles, setObstacles] = useState([]);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(0); // State for high score\n  const [aikoY, setAikoY] = useState(20);\n  const [aikoX, setAikoX] = useState(50);\n  const [gameOver, setGameOver] = useState(false);\n\n  // Fetch high score on initial load\n  useEffect(() => {\n    axios.get('https://localhost:7163/api/score')\n      .then(res => setHighScore(res.data))\n      .catch(err => console.error(\"Could not fetch high score:\", err));\n  }, []);\n\n  // Game loop for moving and spawning obstacles\n  useEffect(() => {\n    if (gameOver) return;\n\n    const gameInterval = setInterval(() => {\n      // Move existing obstacles\n      setObstacles(prevObstacles => {\n        const updatedObstacles = prevObstacles.map(obs => ({\n          ...obs,\n          x: obs.x - 5 // Speed of obstacles\n        }));\n\n        // Check for scoring\n        updatedObstacles.forEach(obs => {\n          if (!obs.scored && obs.x + obs.width < aikoX) {\n            obs.scored = true;\n            setScore(s => s + 1);\n          }\n        });\n\n        // Filter out obstacles that are off-screen\n        return updatedObstacles.filter(obs => obs.x > -200);\n      });\n\n      // Spawn new obstacles\n      setObstacles(prevObstacles => {\n        const lastObstacle = prevObstacles[prevObstacles.length - 1];\n        // Spawn a new obstacle if there are none, or if the last one is far enough away\n        if (!lastObstacle || lastObstacle.x < window.innerWidth - 500) {\n          const newObstacleType = Math.random() < 0.5 ? 1 : 2;\n          return [\n            ...prevObstacles,\n            {\n              id: Date.now(),\n              x: window.innerWidth,\n              type: newObstacleType,\n              width: OBSTACLE_CONFIG[newObstacleType].width,\n              height: OBSTACLE_CONFIG[newObstacleType].height,\n              scored: false\n            }\n          ];\n        }\n        return prevObstacles;\n      });\n    }, 30);\n\n    return () => clearInterval(gameInterval);\n  }, [gameOver, aikoX]);\n\n  // Collision detection\n  useEffect(() => {\n    if (gameOver) return; // Don't check for collisions if game is already over\n\n    const aikoHitbox = { width: 50, height: 100, paddingX: 45 };\n    const aikoLeft = aikoX + aikoHitbox.paddingX;\n    const aikoRight = aikoLeft + aikoHitbox.width;\n    const aikoBottom = aikoY;\n\n    for (const obs of obstacles) {\n      const isHorizontallyOverlapping = aikoRight > obs.x && aikoLeft < obs.x + obs.width;\n      const isVerticallyOverlapping = aikoBottom < 20 + obs.height;\n\n      if (isHorizontallyOverlapping && isVerticallyOverlapping) {\n        setGameOver(true);\n        // Post final score to the backend\n        axios.post('https://localhost:7163/api/score', { score })\n          .then(res => setHighScore(res.data))\n          .catch(err => console.error(\"Could not post score:\", err));\n        return; // Exit after first collision\n      }\n    }\n  }, [obstacles, aikoX, aikoY, gameOver, score]); // Add gameOver and score to dependencies\n\n  const handleRestart = () => {\n    setScore(0);\n    setObstacles([]);\n    setGameOver(false);\n    setAikoY(20);\n    setAikoX(50);\n  };\n\n  return (\n    <div className=\"game-container\">\n      {/* Display Score and High Score */}\n      <div className=\"score-container\">\n        <h1>Score: {score}</h1>\n        <h2>High Score: {highScore}</h2>\n      </div>\n      {gameOver ? (\n        <GameOver onRestart={handleRestart} />\n      ) : (\n        <>\n          <AikoRunner setY={setAikoY} setX={setAikoX} gameOver={gameOver} />\n          {obstacles.map(obs => (\n            <Obstacle key={obs.id} x={obs.x} type={obs.type} />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}